9/15(목) - 사운드부터

사운드도 여러가지 있는데 fmod.com 여기서 쓰는게 제일 편하다
fmod가 천하통일을 했다 ㄷ
fmod 폴더 -> api -> core -> 여기서 inc랑 lib 폴더 안의 것들을 가져다 쓰면 댄다, examples는 말그대로 예시들

우리의 include 폴더 안의 dxtk처럼 fmod 하나 만들고 거따가 ㅇㅇ 
우리의 lib 폴더에 fmod의 lib이랑 dll파일들 갖다놓고

dll은 반드시 실행파일 옆에 있어야한다, 나중에 작업을 해줄 것

fmod_vc.lib 라이브러리는 얘로 연결
fmod.h / fmod.hpp / fmod_errors.h // 헤더는 얘내 셋

fmod의 네임스페이스는 FMOD로 출발한다
FMOD::System*	m_pSystem	-> 이걸 통해서 모든 작업을 다 할수가 잇다
FMOD::Sound*	m_pSound	-> 하나의 사운드파일, 대충 뭐 wav mp3 이런느낌일듯
FMOD::Channel	m_pChannel	-> 

채널 : 하나의 사운드가 여러개의 스피커로 분산되어서 나오는 개념 

- 초기화(Init) 파트
FMOD::System_Create(&m_pSystem);	// 시스템 할당
m_pSystem->init(32, FMOD_INIT_NORMAL, 0);	// 초기화, 얘들은 소문자임ㅋㅋ - 첫번째 매개변수는 최대 몇개의 사운드를 쓸거냐, 두번째는 플래그인데 일단 노말, 세번째는 몰?루

얘들은 파일이름에 유니코드를 지원하지 않읍니다
암튼 클래스에 로드함수 만들어서 사운드파일 이름 매개변수로 받아오고 함수 안에서
m_pSystem->createSound(파일네임, FMOD_DEFAULT, nullptr, &m_pSound); // 매개변수는 왼쪽부터 파일이름, 두번째는 일단 디폴트, 세번째는 뭐 편집에 쓰는건데 지금은안씀, 네번째는 사운드파일반환
m_pSystem->playSound(m_pSound, nullptr, false, &m_pChannel); // 두세번째는 몰루겠고 1,4는 뭐 보면 알잖여
실행이 된놈을 제어하는게 채널, 이따 하시?련ㄴ

dll이 발목을 잡?는데? 프로젝트에서 작업을 할때는 현재폴더에다가 넣어놔도 된다 (디버깅할때는)
근데 실행파일만으로 실행할때는 실행파일 옆에 있어야한다 // 아 그래서 게임폴더 근처에 dll이 그렇게 많았나
오 아무튼 금방 잘되네 진짜 쉽넹

항상 릴리즈 시켜야댐
m_pSound->release();
시스템을 닫고 릴리즈를 시켜야한다, 사실 시스템은 스마트포인터뭐시기가있어서 릴리즈안해도 괜찮긴한데 그래도 해줌
->close(); / -release();
채널은 건들지 않아도 된다, 왜 얘만?

프레임에서 작업을 해볼거임, 멈췄다 실행했다 이거부터
제어를 하려면 채널로 해야함, 
m_pChaneel->getPaused(&bool 머시기) -> 지금 멈춘상태냐 아니냐 반환하는 함수
m_pChaneel->setPaused(bool 머시기) -> 멈추는 함수인듯? true면 멈추겠지?

근데 위에 두개는 따로 함수로 빼고 프레임에서는
m_pSystem->update(); -> 이걸 해줘야 야랄이 안난다

m_pSound->Paused() -> 얘는 선생님이 새로 만든 함수 그건가? 그건갑네 (샘플 프레임에서 쓰임)

볼륨기능도 넣을것임, 올릴것이냐 내릴것이냐 두가지 기능을 한번에 감
볼륨은 0에서 1의값으로 조정함
Volume(float, bool); // 매개변수로 0~1로 볼륨 받고, 올릴지내릴지 bool 하나받아서

FMOD_RESULT도 있네? FMOD_OK면 정상, 나머진 예외처리니까 일단 이것만 알아도댐
시스템->플레이사운드의 반환값이 fr이네 그래서 FMOD_RESULT fr = 시스템->플레이사운드(뭐시기들); 하면되네
채널->getVolume(&float); 하면 볼륨을 받아옴
채널->setVolume(float); 하면 볼륨을 세팅하겠지?

min -> 머임이거 첨보는데, 최댓?값 정하는?것인듯?
암튼 볼륨업/다운 함수 두개만들고,, 아니 뭐 사실 대충 위에 두개만 알면 해보는데 문제는 없것지

사운드 클래스에 Play 함수 추가, 기능은 닉값
그리고 Stop도, 얘는 일시정지가 아니라 완전 꺼버리는거 
둘다 void로

Stop은 채널->stop(); // 쉽네?
Play에서는 1.반복재생 2.한번만틈 두가지 경우가잇는데
bLoop라는것을 매개변수로 받아서, false면 한번만 true면 반복, 디폴트로 flase
사운드->setMode(FMOD_LOOP_NORMAL) // 루프해
사운드->setMode(FMOD_LOOP_OFF) // 루프하지마

아무튼 루프on/off도 Loop함수로 따로 빼서 
매개변수로 위처럼 bool 받아서 온오프해주고
플레이에는 저거두개 있던 자리에 Loop(bool) 요러케

사운드 하나당 채널은 하나, 두번 플레이사운드 하면 채널이 덮어씌워?진다?
뭔진 잘 몰?루겠고 두번실행해도 돌림노래 안되게끔 하면 된다
채널->isPlaying(&bool) // 실행중인지 아닌지 반환, 실행중이면 true 아니면 flase

플레이 두번누르면 원래꺼 꺼지고 새로 켜지는것도 맹글어야쓰것는디
아무튼 플레이이펙트사운드는 돌림노래 OK로 만든다
누를때마다 채널이 반환이된?다? 근데 채널은 하나아님? 이건 좀 헷갈리는디

사운드->getLength(&m_TotalTIme, 밀리세컨드); // 요걸로 사운드파일의 길이를 가져올 수 있음, 근데 매개변수가 몬지는잘몰루겟네
채널->getPosition(&unsigned int, FMOD_TIMEUNIT_MS); // 얘는 위랑 뭐ㅏ가다른교?? 아 얘는 경과시간?

아무튼 저거두개 구해서 Writer클래스의 Draw 이용해서 화면에 띄워보기 드가심

모든 리소스는 항상 매니저가 있어야한다
그러므로 사운드매니저를 만들것이다 ㅋㅋ
사운드매니저에는 디바이스/콘텍스트 지금은 필요없으니 빼버리고
사운드매니저가 사운드시스템을 갖고있게 하겠다, 사운드시스템은 하나여야?할것같긴한데 그래서인가?
그리고 사운드매니저의 인잇에 사운드시스템 만드는 부분도 가져온다
시스템을 넘겨주고 넘겨받을수있게끔
그리고 프레임도 매니저의 프레임을 돌릴것깅다
시스템->업데이트 이것을 매니저의 프레임에 넣어둘 것 (왜?)

오 이제 bgm이랑 이펙트사운드랑 두개 동시에? 하시는데
근데그럼채널이두개되는거아님? 몬가 잘 돌아가긴 하는데? 몰?루겠네?
아무튼 릴리즈 해주고

사운드매니저에 유틸리티? 하나 추가?
암튼 매니저에 파일리스트를 가동시키고
로드 디렉토리? 함수 추가, 아 다음곡 재생 뭐 이런거? 다음곡 이전곡 이런거같은디

 // 윈도우 api임, 근데, 어...
intptr_t handle;
struct _finddata_t fd;
handle = _wfindfirst(dirpath.c_cstr(), &fd);

그... 나중에 LoadDir 다시 보던가.. 어지럽다ㅏ
신기하긴한데 지금당장은 굳이아님? 귀찮으니까 시간남으면해보든가말든가
.은 현재폴더, ..은 상위폴더
재귀를 통해서 하위폴더의하위폴더의.. 암튼 쭊 내려감

굳이 사운드파일 뿐만 아니라 뭐 쉐이더 텍스처 이미지<-특히이놈 
이런것들에도 충분히 써먹을 수 있는 방식이다

모든 매니저에 들어가는 데이터들은 이름이 반드시 있어야한다 (검색이 용이하게끔)
겟스플릿네임 함수로 풀패스가 넘어오면 그 파일이름이랑 확장자 빼고 앞에걸 잘라줘서 리턴할꺼임

사운드매니저에 이제 검색기능도 추가
매니저에 검색기능은 반드시 있어야한다

게임에서는 앵간한건 로딩시간에 다 로딩을 해놓는다 


뭐 아무튼 다 맹글었으니 이제 라이브러리에 추가
이제 그 include/fmod도 그 라이브러리 속성 일반 거시기에 거시기하고
