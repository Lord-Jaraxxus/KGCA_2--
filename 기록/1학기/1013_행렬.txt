10/13(목) - ㅠㅠ 오늘내일 끝나도 토욜날 알바대타네..


오늘은 행렬!

로 넘어가기 전에 벡터 잠깐 다시, 꼭 이해하고 넘어가야 하는거

위치공간과 벡터공간은 다르다..??

위치벡터는 기저벡터에 대한 벡터의 합산이다 // ex) 5, 2, 5  ->  (1,0,0)*5 + (0,1,0)*2 + (0,0,1)*5 

벡터공간이라는게 별도로 있따, 벡터공간은 좌표계가 없다. 상대적인 공간 (한 벡터에 대한? 아 몰?루)
아 근데 우리는 벡터공간을 사용하지 않는다 ㅋㅋ 휴~ 수학쪽에서만 사용한다네요~~


다시 내적으로, 투영
밑에 벡터가 단위벡터라면 계산이 짱 쉬워진다 
어... 그... 뭔 얘긴지 잘? 몰? 루겠소요,,, 
투영 쪽? 얘긴것 같기는 한디,,, 



장실 갔다온사이 행렬 들어온듯 ㄷㄷ

행렬의 곱에서는 반드시 내향일치, 결과는 외향 // ex) [3*2] * [2*4] -> [3*4]
행과 열을 곱한다 (사실 이건 대충은 알고있으니까 머)

행렬의 곱셉은 행벡터 열벡터의 내적이다 ㄷㄷ;; (식이 똑가틈)


단위행렬(I) -> 단위벡터로 이루어진 행렬 (대각선이 1인 행렬, ex - 100 
 						         010
						         001

전치행렬(t) -> 어떤 행렬의 행과 열을 뒤집은 행렬
************ (A*B)t 는 Bt*At 와 같다 (별표 백개, 어마무시하게 중요하다)

역행렬 -> 정사각행렬 A에 대하여 AX =  XA = I 를 만족시키는 행렬 X를 역행렬이라 칸다, A의 -1승으로 표시
***** (A*B)-1 = B-1 * A-1 // 얘도 중요

만약 A행렬이 직교행렬이면 (그래서 직교행렬이 뭐임? ㄹㅇㅋㅋ 성호형 나이스 나도 묻고싶었음)
직교행렬 -> 모든 행, 열의 내적 결과가 0인 행렬 // DirectX에서는 거의 이새끼만쓴다, 단위행렬도 직교행렬임 
아무튼 만약 A행렬이 직교행렬이면 A행렬의 전치행렬과 역행렬은 같다

우리는 앞으로 정점에다가 행렬을 곱하게 될 것
(x, y, z, 1) 에 곱해줄 행렬로 4x4 행렬을 쓸거임 ( [1*4] * [4*4] = [1*4] )

회... 회전... 그때수업안들었는디.. 
원래 2차원 회전공식 : (x,y) -> (xCos*
2차원 기준 : (x,y) * (cos,  sin) -> (x1, y1)
	            (-sin, cos)


행렬식 : 역행렬이 만들어질 수 있는지 판별하는거 (값이 0이 나오면 역행렬이 만들어질 수 없음)
모든 행렬이 역행렬이 구해지는 건 아니다
** 밑줄 쫙 ** 
A행렬의 표기 :	[A]
A행렬식의 표기 :	|A|

샤러스 법칙 : 어.. 대충 저런걸로 계산때려서 0이면 역행렬을 구할 수 없음, 0이 아니면 역행렬을 구할 수 있음 (3*3 행렬까지만 쓸수있음)
소행렬식 사용 : 와... 진짜 뭔지 전혀 모르겠는데 아무튼 이걸 쓰면 모든 행렬의 행렬식을 구할 수 있음, 즉 우리가 쓸 4*4에도 적용가능

여인수 : 그.. 뭐시기냐.. 대충 뭐 빼고 남은거라는 뜻인데.. 아몰랑 필요하면 검색해 
수반행렬 -> 여인수 행렬의 전치행렬임, 역행렬 구할때 사용함

가우스-조르단 : 역행렬을 만들어내는 또다른 방법 (그럼 원래는 뭐였는데;), 근데 이걸로 코드치기는 좀 그렇다. 즉, 그냥 소개만 해놓은거


그 선생님 이거 다 이해하고 지나가야하나요? 어차피 직교행렬만 쓴다면서여... 그냥 전치하면 역행렬이람서..




 ★ 우리가 행렬을 왜 쓰느느냐 -> 정점에 어떤 행렬을 곱해서 변환을 할 거시다 (회전, 확대, 이동?)

행렬의 곱셉은 결합이 가능하다, 보통은 결합을 해서 쓴다 (서순땜에 계산량을 확 쭐일수 있어서)
(x,y,z,1)에서 마지막 1을 쓰는 이유 -> 이동에 쓰려고.	// 막 dx dy dz 있는데 이건 뭐 책에 어디 있것지? -> 교과서 309페이지

 ☆ 행렬을 한 차원 높이면 회전&확대&이동을 한큐에 (하나의 결합행렬을 곱해서) 해버릴 수 있다 		// 유식한 말로 동차좌표계라고 칸다

변환행렬의 결합 서순 : S(신축행렬) * R(회전행렬) * T(이동행렬) * M(기타행렬)



이제 코딩드가서 행렬(Matrix) 클래스를 만들어보자 (일단 2차원부터, 2차원에 쓸 행렬은 3x3)
왜 공용체(union)를 썼느느냐 : 배열로 접근해도 되고, 각각 성분으로 접근해도 되고

일단 단위행렬 만드는 함수인 void Identity 맹글어주고
행렬을 전치시켜서 전치행렬을 반환? 이 아니라 그냥 지를 전치하는 함수 void Transpose 맹글어주고 // 전치행렬을 반환하는 함수도 만들어놓으면 쓸만할지도 아 선생님도 그렇게 바꾸시네
X,Y,Z 축에 대한 회전행렬을 만드는 함수들도 각각 RotationX ~~~ 카믄서 만들어두고 -> 근데 2차원이니까 사실 Z축회전 하나뿐이없음, XY는 없애삐자
확대,축소 담당하는 Scale 만들어주고
Translation은... 최종변환인가? 그냥 곱하는건가? 아닌데? 머지? 아 이동이구나!

결합(곱하기)은 연산자 재정의로 * 오버로드, 자세한건 쌤코드 참고
나는 mat 저거 result로 써야겠다 덜헷갈리게


근데 우리는 3차원 좌표를 가지고 2D에 써먹고 있었던 것이므로,
일단 지금까지 해둔건 냅두고 4x4도 새로 만들것 ㅋㅋ (4x4행렬이 표준이므로 그냥 Matrix라고 함)


어.. 벡터 클래스에 행렬 클래스를 전방선언 해주고 (인클루드 물빨되면 안되니까)
벡터 클래스의 cpp파일에 행렬 클래스를 인클루드 해줌

이동 먼저 하고 회전하면 궤도회전 들어감, 이동한만큼 떠서 원점을 축으로 회전

state에서 cull모드를 back으로 해놔야 시계 반대방향이 안보임
X축회전 Y축회전 할때는 절반이 짤렸는데 왜짤렸을까? NDC 공간을 벗어나서 
0.5에서 회전주면 다 보이는데.. ???? 머지? NDC는 -1 ~ 1 아님?
0이 중간아닌가? 머지?
아 X,Y는 -1 ~ 1인데 Z축만 0~1이었던가? 그랬던 것 같기도 하고 맞네 
OpenGL에서는 Z축도 -1~1인데 DirectX는 Z축만 0~1이네



아무튼 행렬을 쓰면 저러케 확대축소 회전 이동을 편하게 할수가있따
