10/14(금) - ㅅㅂ내일알바대타나가야하네..안한다고할걸..

일단 어제했던거 가볍게 다시 흝고

외적공식을 행렬식으로 표현할 수 있다


아무튼 변환..

정점성분에 있는 모든 것들은(컬러, 텍스처좌표 포함) 벡터다, 즉 행렬로 변화가 가능하다 

역행렬 코딩..
_41, _42, _43, _44 가 0,0,0,1이 아니면 몬가 이상한거, 그래서 걸러준다

오픈GL은 4x1 행렬을 쓴다(열 우선 방식) , DirectX는 1x4 (행 우선 방식)

그런의미에서 (AB)t = BtAt 이 공식이 중요하다!


역행렬정도는... 안보고.. 만들어보라구요..? 해도고만 안해도고만 -> 그럼 안할건데요!

행렬을 다룰때는 정밀도가 높아야한다 ( 평행하냐, 평행하지 않느느냐, 0이냐, 0이 아니냐 이런거 잘 따져야한다)
그래서 수학적인 이해가 되면 수학 라이브러리를 쓰는거, 근데 수학적인 이해가 있어야지! (있어야해요? ㅠㅠ)





오늘은 정말 중요한 개념적인 이해 - 정점 변환에 대해서 설명을 할겁니다

우리가 앞으로 사용해야 되는건 뭐냐, 무한대의 월드공간
버텍스 버퍼에 로컬 내지는 월드를 넣는거야 (일반적으로는 로컬 스페이스의 로컬 정점만 들어간다)

로컬좌표(정점버퍼)를 월드 행렬을 사용해서 변환한다(곱한다) -> 월드 좌표가 된다
로컬의 원점이라는 건 디자이너가 지가 원하는 원점을 잡아서 캐릭터든 뭐든 만든거야 -> 한마디로 지ㅈ대로 라는 뜻?
항상 좌표계 변환은 원점과 원점이 물리는 거야
월드 공간 -> 만든놈을 게임 월드에 떤져놓은 느낌
카메라 들고 찍으러 가는거 -> 뷰 행렬
카메라가 원점이 된 새로운 좌표계가 만들어진다 -> 뷰 정점
어디에서 어디까지만 나오게 할거야? 원근감 있게끔 할거야? 직교투영 할거야? -> 투영 행렬
조리개 노출 등등 이거저거 기술을 주는 느낌
투영행렬은 NDC공간으로 변환까지 해줌
근데 화면에 뿌릴라면 화면 좌표계로 바꿔줘야 함 -> 뷰 포트 행렬이 해준다


지금까지 우리는 투영좌표에 다이렉트로 넣었다,

투영좌표까지는 우리가 해야한다, 나머지는 뷰포트행렬이 알아서해줌
하지만 거까지 갈려면 월드행렬은 어떻게 만들고, 뷰행렬은 어떻게 만들며, 투영행렬은 어떻게 만드는지 알아야 한다



그러므로 32강으로 바로 갈것이다. 뷰행렬하고 투영행렬을 어떻게 만드느느냐 -> 오늘의 핵심

카메라 변환 행렬부터,, 

왜 역행렬이 사용이 되느느냐를 아는게 뷰 행렬 이해의 핵심이다

카메라를 왼쪽으로 가고싶으면 오브젝트(월드)를 오른쪽으로 보내는 것
사실 카메라라는건 없다, 다 가상임
카메라가 움직이는것 처럼 오브젝트를 반대로 움직여줘야한다
카메라는 가만히 있는거야, 아무런 움직임이 없는겁니다

카메라에는 Scale이 들어가지 않습니다


뷰 행렬을 생성하는 방법에는 두가지가 있습니다
1. 외적 사용
2. 내적 사용

그.. 그전부터 계속 몰루겟소요..
엄청나게 중요한 시간이라고 하시는데.. 졸진 않았는데 그.. 뭐라카냐.. 따라가기힘드러요..

- 외적 사용

회전행렬은 코싸싸코로 만드는걸로 알고있었는데
이미 늦었다? 아무튼 바로 회전행렬을 만들 수 있다

x축으로 45도, y축으로 45도, z축으로 45도 돌려 -> 회전행렬 세번 곱하면 됨? 안됩니다. 행렬의 곱셈은 짐볼락?이라고 하는 심각한 오류가 있어서 안된다?
뭐부터 이해를 해야하냐면 회전행렬에 대한 이해부터 다시할게여

오브젝트의 기저(축)을 90도 돌려서 좌표를 봤더니, 코싸싸코 한거랑 같다... ?
나의 위치(eye), 타겟(at) ...?
룩(look)이 어떻게 정해진다?
시계 위치에서 나의 위치를 빼면 방향벡터..가 생성된다?

목표위치라는걸 추가해서 카메라가 바라보는 z벡터를 만들 수 있다..
나머지 x,y축 둘중 하나만 계산하면 나머지 하나는 외적으로 구할 수 있다 (직교 어쩌구저쩌구 하시는데.. 미치겠네)


내가 어느쪽을 바라보냐라는 타겟이 있다면 회전행렬의 결과와 일치하는 행렬을 만들수있다..
카메라의 위치랑 카메라의 목표 위치 + 가상의 업벡터를 하늘로 향하게끔 만들어놓으면

아무튼 외적을 통해서 뷰 행렬을 만들었따..



- 내적 사용 -> 얘가 쪼끔 엑기스가 있다.
전문용어로  그랑슈메트 알고리즘..?

목표위치를 바라보는 벡터와 가상의 업벡터가 직교가 아님, 직교하게 만들려면?
투영을 쓰면 직교하는 벡터를 얻어낼 수 있다, 그럼 나머지 하나는 외적으로 구하면 된다


오브젝트 회전 행렬 -> 타겟이 정해지면 바로 나온다. 단, 뒤집어지면 안된다

회전행렬만 전치해야하지 이동행렬도 전치하면 안되는 것에 주의




이제부터 코딩들어간다..

Identity는 단위행렬 얘기하는거고, 벡터 정규화는 Normal이라고 해줘야댐

뷰행렬을 만들어내는 함수 ViewLookAt 
벡터 3개를 매개변수로 받는데 각각 카메라의 위치, 타겟, 업 이다	// 얘는 외적 이용해서

ObjectLookAt -> 오브젝트가 회전이 되는거
오브젝트가 바라보게끔 할수도 있따... 오브젝트 위치에서 타겟을 바라보게 할수있다	// 얘는 내적 이용해서 만드셨네


투영행렬 다음시간에 할거긴 한데 일단 코드에 추가

솔루션->속성 가서 프로젝트 종속성에서 이렇게저렇게 하면 참조추가한거랑 결과가 같다


원래 1x3이 아니라 1x4가 들어가야한다..,,, 그래서 지금 좀 거시기가 있는데 다음에 투영 할때 어떻게 하시것지 뭐




카메라가 변환이 되어서 움직인다, 그 카메라의 행렬을 완성을 했다 -> 이게 오늘 중요한거

사실 뷰행렬 자체는 별것 아니다, 뷰행렬을 만들어내는 과정이 중요한거 (그랑슈메트 뭐시기라던지..)



Q : 그래서 업벡터는 왜 무조건 (0, 1, 0) 임? 
아니 z축이 시선벡터랑 일치하는건 존나게 그냥 무한대잖아

A : 두시간 넘게 존나 고민한 결과 깨닫긴 했는데 ㅅㅂ 나만몰랐나봐
아무튼 꼭 (0,1,0) 이어야 하는건 아닌데, yz축 평면 안에 있는 직선이어야함 
근데 yz축 평면은 look이 어디로 지랄염병하면서 가도 y축과 수직임, 즉 항상 (0,1,0) 을 포함함 	// 뭐 0,2,0 아니면 0,-1,0 이런것도 항상 포함하긴 할텐데 계산 쉽게 0,1,0인듯 

그러므로 일단 0,1,0 기준으로 외적해서 x축 구해주고, 또 외적해서 y축 수정하던가 
아니면 0,1,0 기준으로 내적해서 y축먼저 구해주고 z축 y축으로 x축 구해주면 됨



Q : memcpy는 왜 해주신거? 

Q : 왼손 좌표계에서는 외적할때 무조건 b X a 라고 하셨는데, a랑 b 정하는 기준이 뭐임??