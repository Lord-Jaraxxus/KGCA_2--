1/3(화) - 오늘은 코딩 들어감ㄷㄷ

일단 어제했던거 잠깐 다시 보고 넘어가고
+a 쪼금 더 보시는데 어제꺼 확장이라는 느낌이라 머

NAT -> 상식으로 알아둬야 할? 
공인 IP를 업체가 사설 IP 여러개로 쪼개서 서비스하는 그런느낌



소켓 프로그래밍은 다합쳐도 함수가 열몇개밖에 없다, 개꿀인데?
하지만 함수가 적다 = 쉽다는 아니겠?지?

아무튼 개론 끝났고, 이제 코딩의 영역 드러갑니다

새 프로젝트 추가 -> 콘솔 프로그래밍 (윈도우로 해도 되고 뭐)
#include <winsocket2.h> 하면서 추가

추가 종속성 라이브러리에 ws2_32.lib 넣어주면 된다 

WSAStartup(); 이걸로 호출을 하고
WSACleanup(); 이걸로 마무리한다

근데 스타트업 위에 저거 뭐냐 워드랑 뭐냐
아무튼 구조체 두개정도 선언을 해주?는? 아니네?

워드는 보통 매크로를 쓴다? 

WSADTA wsa;
WSAStartup(MAKEWORD(2,2), &wsa);   // 2.2버전이라는 뜻, 2000년대 후반부터는 무조건 2.2였다

위에 스타트업의 리턴값이 0만 아니면 된다

아무튼 이제 소켓을 만들꺼임
SOKET sock[변수이름] = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP) 
 // 맨앞은 IP를 쓰겠다, 스트림 소켓 = TCP  소켓, DGRAM 소켓 = UDP 소켓
근데 마지막 매개변수에 0 넣으면 TCP UDP 알아서 따라가준다

마지막엔 closesocket을 무조건 해줘야한다
소켓이라는게 파일포인터라고 생각해주면 됨

클라이언트 같은 경우에는 connect로 접근

SOCKADDR_IN sa;
sa.sin_family = AF_INET;
sa.sin_addr = inet_addr(); // 구한말때 함수긴 한데, 일단 이걸로
sa.sin_port = htons(1000);
connect(sock, (*sockaddr)&sa[목적지+포트], sizeof(sa));

원래 sockaddr로 넘겨줘야 하는데, 편의성울 위해서 SOCKADDR_IN을 쓴다

inet_addr라는 함수를 쓰면 문자열을 long으로 바꿔준다

포트번호 지정할땐 htons라는 함수를 써야한다 (Host To Network Short)
빅엔디안(네트워크 바이트 정렬), 리틀엔디안(호스트 바이트 정렬)
빅엔디안은 그대로 저장, 리틀엔디안은 거꾸로 저장
원래 메모리에 저장될때는 리틀엔디안마냥 거꾸로 저장이 되고 있었다
근데 connect함수가 해석할때는 곧이곧대로 읽어서 거꾸로 읽어삔다
그래서 htons로 입맛에 맞게 바꿔서 먹여준다

네트워크 관련 함수들은 죄다 빅엔디안 쓴다

connect가 실패하면 SOCKET_ERROR(-1) 반환, 성공하면 0 반환

보내는 놈의 포트번호는 운영체제가 알아서 멕여준다, 보낼 때 받을 놈의 포트번호만 지정하면 된다

이제 데이터를 주고받을꺼임, 두가지만 알아
sand();
recv();

recv의 반환값이 0이면 접속을 종료했다 라는 뜼




아무튼 이제 서버 호스트?를 하러갑니다

bind();
listen();
accept();

일케 세개가 추가됩니다

바인드가 커넥트랑 매칭된다고 보면 됨, 소켓에다가 sa의 정보를 묶어준다

리슨은 들을 준비 됬다 드루와 라는 뜻ㅎ, 이걸 하면 접속을 받아줄 수 있?는것같은데

accept는 누군가 접속하면 뭔가가 반환이 된다 
sizeof로 직접넣으면 안되고 int length = sizeof머시기 일케넣어야함 
아무튼 클라이언트 소켓이라는게 반환이 된다

근데 서버 열게요 하고 뭔가 다이내믹하고 웅장한 뭐시기는 안해도되남??
그냥 대충 저러면 서버가 뿅하고 열리는겨?

블록형함수? 어떤 작업의 조건이 만족해야만 반환이 된다
근데 저거는 말이안된다, 그래서 나중에 넌블록형 함수로 바꿀꺼다 정확히는 넌블록형 소켓인데 암튼

htonl(INADDR_ANYU); // 시스템에 장착된 모든 ip를 다 받아주겠다 라는뜻


send가 보내면 반환한다고 해놨지만 
사실 send가 운영체제의 send버퍼에 저장하면 반환이 되는거다
실제로 보내는건 운영체제임

받는것도 마찬가지, 내 운영체제의 recv버퍼에 저장이 되면 반환이 된다 


아무튼 실시간 양방향 통신을 위해서 블록형 소켓을 넌블록형 소켓으로 바꿀꺼다
소켓을 생성하고 ioctlsocket 이함수를 쓰면 넌블록형 소켓으로 바뀐다

u_long iMode = TRUE; // TRUE면 밑에껄 실행함, FALSE면 안함
ioctlsocket(sock0, FIONBIO, &iMode); 

아무튼 넌블록형 소켓으로 바꿨으면 이제 반환결과가 그냥 반환한건지 오류인지 성공한건지 체크해야댐 그래서 
if (WSAGetLastError() != WSA E WOULD BLOCK) // 이걸로 검사함, 오른쪽껀 붙여써야댐ㅎ
저 조건이 참이면 오류라는 뜻, 거짓이면 그냥 반환이라는 뜻 

connect send recv 이런애들을 운영체제가 대리로 해주는데 그게 즉각적으로 되는 게 아니라서
애매한 시간간격이 생길 수 있다, 이런 걸 고려해줘야하겠는걸?

아무튼 지금 이상황에선 fgets 이새끼때문에 턱 막혀버림
그래서 멀티스레드?를?써야한?다?

근데 멀티스레드를 쓰면 그것때문에 또 문제가 생기고 그걸 해결하려고 쓴 방법때문에 또 문제가 생기고..
막 그렇게 반복일 것