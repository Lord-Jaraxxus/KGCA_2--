1/5(목) - 잠좀일찍자라영민아ㅏㅏ

fgets는 블록형이니까, 이걸 대체할 모몬가가 있어야한다

스레드? 종업원 같은 느낌인디, 이걸 여러개 써서 해결할것

윈도우 API 스레드 (구한말때부터 사용)
C++11부터 스레드라는 별도의 기능이 지원된다 

일단 고전적인 방법부터 시작을 합시다잉

스레드를 통해서 고객의 입력을 별도로 받는 작업을 해볼꺼



CreateThread <- 스레드를 만드는 함수, 윈도우 API

세번째 매개변수인 스타트루틴이 메인함수? ㅇ믐.. 아무튼 함수포인터를 매개변수로 받는다
시작함수? 스레드의 스타트루틴 즉 시작함수는 그 스레드의 메인함수가 된다.. 음.. 

네번째 매개변수는 스레드에 넘겨줄 매개변수 칸, 소켓을 넘?길거임?

마지막 매개변수는 만들어진 스레드의 ID를 리턴해줌

CreateThread도 반환값이 있음, 핸들임. 이걸로 제어를 한다

근데 코드만 대충 쳐놓으면 바로 꺼져버리니까 
while문으로 알바가 퇴근 못하도록 막아놓음

아무튼그래서 send역할을 다른 스레드로 빼놨다


타임 셰어링? 시간을 서로 쪼개서 작업을 하는것
운영체제는 모든 프로세스를 동시에 돌리는 것이 아니라, 매우 짧은 시간동안 모두를 한번씩 돌린다 

아무튼 핵심은 동시다발적으로 도는게 절대로 아니다, A쓰레드 돌리고 B쓰레드 돌리고 이걸 무한반복
동시다발적으로 도는건 병렬 프로세싱이라고 부른다 

아무튼 그래서 스레드랑 스레드를 왔다갔다하는 뭐시기가 필요할 것
그렇지 않으면 운영체제에 모든 걸 맡기는 것임
sleep을 먹이면 운영체제가 다른 스레드로 간다

점유 -> 한 스레드가 무한으로 돌아서 다른 스레드로 안 가는 것, 이러케되면 안된다

아무튼 스레드의 우선권을 설정해줘야할?것

스레드도 소켓 닫듯이 CloseHandle로 닫아주는것이 국룰
근데 핸들을 종료한다고 스레드가 종료되는 것은 아니다 그래도 예의상 암튼해줌


서버 코드로 가서, 여기도 스레드를 하나 만들고 send/recv 작업을 하게 만든다
서버에서 받아오는 소켓은 리스닝 소켓이라고 주로 칭한다

그리고 손님 하나당 종업원 하나씩을 붙여준다 (누군가 접속하면 소켓을 만들어서 배정해줌)

스레드를 가장 안전하게 종료할 수 있는 방법 -> 스레드의 시작함수를 리턴하는 것 (리턴하고 종료되게끔)

오 클라 두개 접속시킴ㄷㄷ 이제 여럿 접속시킬 수 있을듯


근데 아직 채팅 시스템은 아님, 모든 유저가 볼 수 있게 채팅을 전송해줘야한다
배열?을쓰려다가? 아 stl로 그냥 꺾어서 list를쓴다
아무튼 들어오는 모든 유저의 소켓을 리스트에 저장해준다

오 다대다 채팅 완성 ㄷㄷ 쩐다 


이제 구조체를 통해서 (나중엔 클래스로 바뀔거임) 유저의 정보를 저장해서 다른 스레드에 넘?겨준다
리스트 erase때문에 생기는 사소한 문제를 조금 손봐주고,,

서버에서 클라 접속 종료가 정상/비정상인지도 체크해주고
클라에서도 마찬가지, 서버 정상/비정상 종료 체크할 수 있게 해줌


지금은 유저마다 스레드를 하나씩 붙여놨는데, 이건 좀 비효율적
그래서 서버의 기능을 조금 바꿀것, 한 스레드에서 모든 유저들을 컨트롤하게끔



클라에서 보낼때 보내는 데이터의 크기를 기입해놓는다 -> 이런게 프로토콜(규약)
그럼 이제 서버에서 recv 받을때 그만큼만 받아올 수 있고, 그만큼 안왔으면 기다렸다 받고 뭐 그럴수도 있고

암튼 그래서 프로토콜이라는 헤더파일을 하나 만들어서
거따가 패킷 헤더 구조체 하나 만들고, 유저 패킷 구조체도 하나 만들고 ㅇㅇ
패킷 헤더 사이즈도 만들어놓으면 편하다 

이제 그걸로다가 메세지를 주고받고 할꺼임
클라에서 SendMsg라고 send부분을 함수로 빼버림

그리고 이제  recv에서 패킷헤더만큼(지금은4바이트) 받아오고 시작할 것, 
패킷 헤더만큼 못받았으면 더 받을때까지 기다릴것 (ex - 2바이트만 왔을경우, 근데 이런 경우가 실제로 있나??)
메세지 내용도 비슷하게, 헤더에서 알려준 크기만큼 가져올때까지 recv 반복해줌

나중엔 패킷 헤더에 언제 보냈는지 시간 정보도 같이 보낼것 





Q. 만약에 저렇게 했는데 예를들어서 A가 300바이트 보내고 B가 200바이트 보냈음
근데 그럴때 서버가 A꺼 100바이트 먼저 받고 다시 300바이트 받아올랬는데 B가 보낸거랑 섞이면 어떡함? -> 아 그래서 길이를 저장해놓지 참
그 리시브 버퍼에 데이터가 어떤 꼬라지로 쌓이는지를 좀 알고싶은데

그리고 A 100 B 200 이런식으로 스까서 들어오는 것도 가능함? 가능하면 어케 해결하지?

마지막으로 그 뭐더라 갑자기 기억이 안나네 아 그거
점유 문제는 어케 해결함? 근데 이건 나중에 하시겠지 뭐 
