1/16(월) - 이게 커피가 없네.. 이따 나가서 사와야하나(사옴)


전시간에 비동기 파일 입출력을 했었음, 이번 시간에는 소켓에다가 붙일거임

비동기 작업의 결과를 어떻게 통지받느느냐 -> 반환값, 이벤트, 완료 루틴?
FileRead FileWrite가 WSARecv WSASend로 바뀌었음, 얘내 둘은 WSA버퍼? 를 쓴다? 

우리가 오늘 해야할거 
1. 완료 루틴 (컴플레이션 루틴, CR)
2. 완료 포트(컴플레이션 포트, CP) -> IOCP 

완료 루틴과 완료 포트 두 가지로 비동기 작업의 결과를 통지받을 것?

서버는 최소한 IOCP로 구현을 해야함

암튼 저번에 만든건 한번에 다 읽고 한번에 다 쓰고 이랬는데, 
한 마디씩 읽고 쓰고 읽고 쓰고 일케 할 수도 있다 -> 근데 통신을 하다보면 그렇게 안 된다?? 


코?딩 시작 (IOCP_0)

음.. 잘 모르겠찌만 아무튼 한번 읽고 한번 쓰고 이런 식으로 되게끔 저번에 했던걸 바꾸시는?듯 (읽자마자 써라)
-> 이거 만드시고 1교시 끘

이제 쓰레드 버전이랑 쓰레드 아닌 버전으로 구분? 에에엣.. 쓰레드 안쓰는거 아녔나

암튼 쓰레드 버전부터 시작, C++버전 쓰레드를 쓸건데 얘는 핸들(_beginthreadex의 반환값)이 unsigned long이다
어.... 몬가몬가인데.. 그냥 머 위에거 쓰레드버전으로 바꿨다 끘 이겠지?
암튼 쓰레드화 시켰는데, 위엣것마냥 읽고쓰고 읽고쓰고가 이쁘게 되는 게 아니라 
읽고읽고쓰고읽고 읽ㄱ쓰고쓰고쓰ㄱㅗ읽고 머 일케 야랄날수도 있겠제
그래서 싱크를 맞춰줄 필요가 있음, 이벤트라는 거슬 통해서
Write 파트에서 WaitForSingleObject로 시그널(이벤트의)이 올 때 까지 대기시킨다
그리고 Read 파트에서 ::SetEvent로 시그널을 준?다
그렇게 해서 읽고쓰고 읽고쓰고 착착 맞아떨어지게 만들었음 챤챤
이제 메인에서 while(1)하나 만들고 거기서도 똑같은 이벤트를 대기하게끔 하고, 현재 진행 상황을 printf로 보여주게끔 해보겠다 (퍼센테이지)
몬가 대충 되긴 되는데 마지막에 짜투리땜에 멈춰삐네, 살짝 고쳐주고 머 이제 잘되네 


IOCP_1 시작, 얘는 뭐하는놈이려나 -> 본격적으로 포트번호(CP)쓰는놈

지금 두 놈이(Write, 메인) WaitForSingleObject로 똑같은 이벤트를 대기중인데 이러면 사실 둘 중 하나만 돌아가고 하나는 블록당함,
이런 경우에는 이벤트를 하나 더 만들거나 수동 리셋 이벤트로 해주거나 해줘야댐

..이었는데 이제 WorkProc라고 하나의 쓰레드로 합칠거심.. 이 아닌데 머지
메인에서 읽고쓰고를 한다?? ㅔㅔ.. .. ..? 이미 와칸네..

WorkProc쓰레드에서 비동기 작업 완료 통지를 캐치할 것?
CreateIoCompletionPort라는 함수를 쓸 거야, 세 번 쓸거야 -> 얘가 그 IOCP의 CP고마잉
어... 첫번째는 핸들 선언?같고 
두번째건 hReadFile에 1111이라는 포트번호를 바인딩, 
세번째건 hWriteFile에 2222라는 포트번호를 바인딩 한??? 느낌?? 
GetQueuedCompletaionSataus(핸들, a, b, c, d) 라는 함수를 가동할 수가 있따,,
a : 트랜스퍼?
b : 키 밸류? 포트번호를 리턴해주는?듯! -> 이게 핵심!
c : 오버랩 구조체? 를 리턴해줌
d : 타임아웃

에....... 쥰내 헷갈리긴 하지만 암튼 포트번호 이용해서
읽기가 됐다 -> 써라! / 쓰기가 됐다 -> 읽어라! 이렇게 돌아가게끔 해놨다
이것도 짜투리 이슈 발생, 몬가,,,몬가몬가몬가 이렇게저렇게 해서 해?결 된듯 하이
코드 디버깅하면서 분석을 해보아야쓰것어,, 

암튼 지금은 읽고 쓰고 읽고 쓰고 이쁘게 되는데, 쓰레드가 여러개 돌아가면 읽기읽기ㅇ쓰기쓰ㄱ읽기 막 이지랄날수도있?다 
